\chapter{PROGRAM OPERASI PENJUMLAHAN MATRIKS}
\label{appx:addition}
% \section{Kode untuk dijalankan di GPU}\label{kode_potential_cpp}

\section{\emph{Module}}

\begin{lstlisting}
using CUDA
using DataFrames
using Statistics
\end{lstlisting}

\section{Untuk dijalankan di GPU}

\begin{lstlisting}
function operation_cuda(A, B)
    C = CUDA.zeros(Float16, size(A))
    CUDA.@sync C .= A .+ B
    return C
end

function simulate_gpu(A_normal, B_normal)
    # Convert your Float64 matrices to Float32 and then to CuArray{Float32}
    A = CUDA.convert(CuArray{Float16}, A_normal)
    B = CUDA.convert(CuArray{Float16}, B_normal)
    # Mengukur waktu eksekusi
    cuda_start = CUDA.@elapsed result_gpu = operation_cuda(A, B)
    return cuda_start
end
\end{lstlisting}

\section{Untuk dijalankan di CPU}

\begin{lstlisting}
function operation_cpu(A, B)
    C = zeros(Float16, size(A))
    C .= A .+ B
    return C
end

function simulate_cpu(A_normal, B_normal)
    normal_start = @elapsed result_cpu = operation_cpu(A_normal, B_normal)
    return normal_start
end
\end{lstlisting}

\section{Simulasi}

\begin{lstlisting}
function simulate(N::Int64, n_loop::Int64)
    println("Total size: $(N*N)")
    results_gpu = []
    results_cpu = []
    for i in 1:n_loop
        A_normal = rand(Float16, N, N)
        B_normal = rand(Float16, N, N)
        benchmark_gpu = simulate_gpu(A_normal, B_normal)
        benchmark_cpu = simulate_cpu(A_normal, B_normal)
        push!(results_gpu, benchmark_gpu)
        push!(results_cpu, benchmark_cpu)
    end
    println("Mean CPU: $(mean(results_cpu))")
    println("Mean GPU: $(mean(results_gpu))")
    return DataFrame(CPU=results_cpu, GPU=results_gpu)
end
\end{lstlisting}

\chapter{PROGRAM OPERASI PENGURANGAN MATRIKS}
\label{appx:substraction}

\section{\emph{Module}}

\begin{lstlisting}
using CUDA
using DataFrames
using Statistics
\end{lstlisting}

\section{Untuk dijalankan di GPU}

\begin{lstlisting}
function operation_cuda(A, B)
    C = CUDA.zeros(Float16, size(A))
    CUDA.@sync C .= A .- B
    return C
end

function simulate_gpu(A_normal, B_normal)
    # Convert your Float64 matrices to Float32 and then to CuArray{Float32}
    A = CUDA.convert(CuArray{Float16}, A_normal)
    B = CUDA.convert(CuArray{Float16}, B_normal)
    # Mengukur waktu eksekusi
    cuda_start = CUDA.@elapsed result_gpu = operation_cuda(A, B)
    return cuda_start
end
\end{lstlisting}

\section{Untuk dijalankan di CPU}

\begin{lstlisting}
function operation_cpu(A, B)
    C = zeros(Float16, size(A))
    C .= A .- B
    return C
end

function simulate_cpu(A_normal, B_normal)
    normal_start = @elapsed result_cpu = operation_cpu(A_normal, B_normal)
    return normal_start
end
\end{lstlisting}

\section{Simulasi}

\begin{lstlisting}
function simulate(N::Int64, n_loop::Int64)
    println("Total size: $(N*N)")
    results_gpu = []
    results_cpu = []
    for i in 1:n_loop
        A_normal = rand(Float16, N, N)
        B_normal = rand(Float16, N, N)
        benchmark_gpu = simulate_gpu(A_normal, B_normal)
        benchmark_cpu = simulate_cpu(A_normal, B_normal)
        push!(results_gpu, benchmark_gpu)
        push!(results_cpu, benchmark_cpu)
    end
    println("Mean CPU: $(mean(results_cpu))")
    println("Mean GPU: $(mean(results_gpu))")
    return DataFrame(CPU=results_cpu, GPU=results_gpu)
end
\end{lstlisting}

\chapter{PROGRAM OPERASI PERKALIAN SKALAR DENGAN MATRIKS}
\label{appx:multiplication_scalar_matrix}

\section{\emph{Module}}

\begin{lstlisting}
using CUDA
using DataFrames
using Statistics
\end{lstlisting}

\section{Untuk dijalankan di GPU}

\begin{lstlisting}
function operation_gpu(A, skalar)
    C = CUDA.zeros(Float32, size(A))
    CUDA.@sync C = A * skalar
    return C
end

function simulate_gpu(A_normal, skalar_normal)
    A = CUDA.convert(CuArray{Float32}, A_normal)
    cuda_start = CUDA.@elapsed result_gpu = operation_gpu(A, skalar_normal)
    return cuda_start
end
\end{lstlisting}

\section{Untuk dijalankan di CPU}

\begin{lstlisting}
function operation_cpu(A, skalar)
    C = zeros(Float32, size(A))
    C = A * skalar
    return C
end

function simulate_cpu(A_normal, skalar)
    normal_start = @elapsed result_cpu = operation_cpu(A_normal, skalar)
    return normal_start
end
\end{lstlisting}

\section{Simulasi}

\begin{lstlisting}
function simulate(N::Int64, n_loop::Int64)
    println("Total size: $(N*N)")
    results_gpu = []
    results_cpu = []
    for i in 1:n_loop
        A_normal = rand(Float32, N, N)
        scalar_normal = rand(Float32)  # Generate a random scalar
        benchmark_gpu = simulate_gpu(A_normal, scalar_normal)
        benchmark_cpu = simulate_cpu(A_normal, scalar_normal)
        push!(results_gpu, benchmark_gpu)
        push!(results_cpu, benchmark_cpu)
    end
    println("Mean CPU: $(mean(results_cpu))")
    println("Mean GPU: $(mean(results_gpu))")
    return DataFrame(CPU=results_cpu, GPU=results_gpu)
end
\end{lstlisting}

\chapter{PROGRAM OPERASI PERKALIAN ANTAR MATRIKS}
\label{appx:multiplication_matrix_matrix}

\section{\emph{Module}}

\begin{lstlisting}
using CUDA
using DataFrames
using Statistics
\end{lstlisting}

\section{Untuk dijalankan di GPU}

\begin{lstlisting}
function operation_gpu(A, B)
    C = CUDA.zeros(Float32, size(A))
    CUDA.@sync C = A * B
    return C
end

function simulate_gpu(A_normal, B_normal)
    A = CUDA.convert(CuArray{Float32}, A_normal)
    B = CUDA.convert(CuArray{Float32}, B_normal)
    cuda_start = CUDA.@elapsed result_gpu = operation_gpu(A, B)
    return cuda_start
end
\end{lstlisting}

\section{Untuk dijalankan di CPU}

\begin{lstlisting}
function operation_cpu(A, B)
    C = zeros(Float32, size(A))
    C = A * B
    return C
end

function simulate_cpu(A_normal, B_normal)
    normal_start = @elapsed result_cpu = operation_cpu(A_normal, B_normal)
    return normal_start
end
\end{lstlisting}

\section{Simulasi}

\begin{lstlisting}
function simulate(N::Int64, n_loop::Int64)
    println("Total size: $(N*N)")
    results_gpu = []
    results_cpu = []
    for i in 1:n_loop
        A_normal = rand(Float32, N, N)
        B_normal = rand(Float32, N, N)
        benchmark_gpu = simulate_gpu(A_normal, B_normal)
        benchmark_cpu = simulate_cpu(A_normal, B_normal)
        push!(results_gpu, benchmark_gpu)
        push!(results_cpu, benchmark_cpu)
    end
    println("Mean CPU: $(mean(results_cpu))")
    println("Mean GPU: $(mean(results_gpu))")
    return DataFrame(CPU=results_cpu, GPU=results_gpu)
end
\end{lstlisting}


\chapter{PROGRAM OPERASI INVERSE MATRIKS}
\label{appx:inverse}

\section{\emph{Module}}

\begin{lstlisting}
using CUDA
using DataFrames
using Statistics
\end{lstlisting}

\section{Untuk dijalankan di GPU}

\begin{lstlisting}
function operation_matrices_cuda(gpu_matrix)
    inverted_gpu_matrix = inv(gpu_matrix)  
    return inverted_gpu_matrix  
end

function simulate_gpu(A_normal)
    A = CUDA.cu(A_normal)  
    result_gpu, cuda_start = CUDA.@timed operation_matrices_cuda(A)
    return cuda_start 
end
\end{lstlisting}

\section{Untuk dijalankan di CPU}

\begin{lstlisting}
function operation_matrices_normal(A)
    C = zeros(Float32, size(A))
    C = inv(A)
    return C
end

function simulate_cpu(A_normal)
    normal_start = @elapsed result_cpu = operation_matrices_normal(A_normal)
    return normal_start
end
\end{lstlisting}

\section{Simulasi}

\begin{lstlisting}
function simulate(N::Int64, n_loop::Int64)
    results_gpu = []
    results_cpu = []
    for i in 1:n_loop
        A_normal = rand(Float32, N, N)
        benchmark_gpu = simulate_gpu(A_normal)
        benchmark_cpu = simulate_cpu(A_normal)
        push!(results_gpu, benchmark_gpu)
        push!(results_cpu, benchmark_cpu)
    end
    println("Mean CPU: $(mean(results_cpu))")
    println("Mean GPU: $(mean(results_gpu))")
    return DataFrame(CPU=results_cpu, GPU=results_gpu)
end
\end{lstlisting}

\chapter{PROGRAM PENCARIAN NILAI EIGEN}
\label{appx:eigenvalue}

\section{\emph{Module}}

\begin{lstlisting}
using CUDA
using DataFrames
using Statistics
\end{lstlisting}

\section{Untuk dijalankan di GPU}

\begin{lstlisting}
function eigen_gpu(A_gpu)
    A_cpu = Array{Float64}(A_gpu)
    return eigvals(A_cpu)
end

function simulate_gpu(A_normal)
    A_gpu = CUDA.cu(A_normal)
    gpu_start = CUDA.@elapsed result_gpu = eigen_gpu(A_gpu)
    return gpu_start
end
\end{lstlisting}

\section{Untuk dijalankan di CPU}

\begin{lstlisting}
function eigen_cpu(A)
    return eigvals(A)
end

function simulate_cpu(A_normal)
    cpu_start = @elapsed result_cpu = eigen_cpu(A_normal)
    return cpu_start
end
\end{lstlisting}

\section{Simulasi}

\begin{lstlisting}
function simulate(N::Int64, n_loop::Int64)
    println("Matrix size: $(N)x$(N)")
    results_gpu = []
    results_cpu = []
    for i in 1:n_loop
        A_normal = rand(Float64, N, N)
        benchmark_gpu = simulate_gpu(A_normal)
        benchmark_cpu = simulate_cpu(A_normal)
        push!(results_gpu, benchmark_gpu)
        push!(results_cpu, benchmark_cpu)
    end
    println("Mean CPU time: $(mean(results_cpu))")
    println("Mean GPU time: $(mean(results_gpu))")
    return DataFrame(CPU=results_cpu, GPU=results_gpu)
end
\end{lstlisting}
